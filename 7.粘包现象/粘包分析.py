"""
粘包现象
    由于服务端接收命令的时候是需要指定大小的
    但是命令执行的结果长度可能超过指定的大小
    那么剩下的内容就会和下次执行命令的结果一起返回，这就是粘包现象

产生原因
    未接收完的数据给继续存在通信管道中
    产生数据积压，而管道里面的数据结构是队列，即按顺序读取

底层原理分析
    客户端和操作系统都是一个程序，都有自己的内存空间，他们之间是相互隔离的

    你的程序实际上无权直接操作网卡的，你操作网卡都是通过操作系统给用户程序暴露出来的接口
    那每次你的程序要给远程发数据时，其实是先把数据从用户态copy到内核态
    这样的操作是耗资源和时间的，频繁的在内核态和用户态之间交換数据势必会导致发送效率降低
    因此 socket为提高传输效率，发送方往往要收集到足够多的数据后オ发送一次数据给对方
    若连续几次需要send的数据都很少，通常TCP socket会根据优化算法把这些数据合成一个TCP段后一次发送出去，这样接收方就收到了粘包数据

总结
    1.TCP( transport control protocol,传输控制协议)是面向连接的，面向流的，提供高可靠性服务
    收发两端（客户端和服务器端）都要有一一成对的socket,因此，发送端为了将多个发往接收端的包，更有
    效的发到对方，使用了优化方法(Nagle算法)，将多次间隔较小且数据量小的数据，合并成一个大的数据块，
    然后进行封包。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。即面向流的通信是无消息保护边界的


    2.UDP( user datagram protocol,用户数据报协议)是无连接的，面向消息的，提供高效率服务
    不会使用块的合并优化算法，由于UDP支持的是一对多的模式，所以接收端的 skbuff（套接字缓冲区）采用
    了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息），
    这样，对于接收端来说，就容易进行区分处理了。即面向消息的通信是有消息保护边界的

    3.tcp是基于数据流的，于是收发的消息不能为空，这就需要在客户端和服务端都添加空消息的处理机制，
    防止程序卡住，而udp是基于数据报的，即便是你输入的是空内容（直接回车），那也不是空消息，udp协议会帮你封装上消息头

理解
    recv操作很耗费时间和资源（要三次握手，建立通道，传输数据，被操作系统捕获） —— 网络io
    conn操作是在本地与操作系统的io操作，相比recv，时间短很多              -- 本地io

    所以TCP协议有优化的算法，把多次频繁且时间间隔短的网络io合并在一起发送，从而造成服务端的粘包现象
    如果服务端给客户端发数据的间隔很短，也会造成客户端的粘包现象
    还有如果接收时没有把数据完全收完，也会有粘包现象

    总结：造成粘包现象的原因有两种
        间隔时间短
        数据没收完

解决办法
    无论是那种原因造成粘包现象，最好的解决办法就是知道每次发送的数据是多大
    这样就算他们粘在一起了，也可以收取指定大小的数据，从而把数据分开
    实现方法有制作自己的报头，把数据大小传过去，然后分析报头知道大小，从而解决粘包问题
"""